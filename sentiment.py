# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12rlB4hCnYNCu4XBgCLuASzkrYqNsz17j
"""

import numpy as np
import pandas as pd
import joblib
import pickle

data = pd.read_csv('Restaurant_Reviews.tsv',delimiter = '\t',quoting=3)

# print(data)

import nltk

nltk.download('stopwords')

import re
import nltk
from nltk.corpus import stopwords
from nltk.stem.porter import PorterStemmer
corpus=[]
review_process=[]
print(type(corpus))
for i in range(0,1002):
  review = re.sub('[^a-zA-Z]'," ",data['Review'][i])
  review = review.lower()
  review = review.split()
  ps = PorterStemmer()
  all_stopwords = stopwords.words('english')
  # all_stopwords.remove('not')
  review = [ps.stem(word) for word in review if not word in set(all_stopwords)]
  review = ' '.join(review)
  corpus.append(review)
# print(corpus)



from sklearn.feature_extraction.text import CountVectorizer
cv = CountVectorizer(max_features = 1600)
X = cv.fit_transform(corpus).toarray()
# print(X)
print(len(X))
y = data.iloc[:, 1].values
print(y)
print(len(y))

with open("cv.pkl","wb") as file:
  pickle.dump(cv,file)
# joblib.dump(cv, "cv.pkl")


from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 42)

from sklearn import linear_model
classifier = linear_model.LogisticRegression(C=1.5)
classifier.fit(X_train, y_train)

# Predicting the Test set results
y_pred = classifier.predict(X_test)
print(y_pred)
# joblib.dump(classifier, "model.pkl")

with open("model.pkl","wb") as file:
  pickle.dump(classifier,file)

# Making the Confusion Matrix
from sklearn.metrics import confusion_matrix
cm = confusion_matrix(y_test, y_pred)
print ("Confusion Matrix:\n",cm)

# Accuracy, Precision and Recall
from sklearn.metrics import accuracy_score
from sklearn.metrics import precision_score
from sklearn.metrics import recall_score
from sklearn.metrics import f1_score
score1 = accuracy_score(y_test,y_pred)
score2 = precision_score(y_test,y_pred)
score3= recall_score(y_test,y_pred)
print("\n")
print("Accuracy is ",round(score1*100,2),"%")
print("Precision is ",round(score2,2))
print("Recall is ",round(score3,2))

from sklearn.naive_bayes import MultinomialNB
classifier = MultinomialNB(alpha=0.1)
classifier.fit(X_train, y_train)

# Predicting the Test set results
y_pred = classifier.predict(X_test)

# Making the Confusion Matrix
from sklearn.metrics import confusion_matrix
cm = confusion_matrix(y_test, y_pred)
print ("Confusion Matrix:\n",cm)

# Accuracy, Precision and Recall
from sklearn.metrics import accuracy_score
from sklearn.metrics import precision_score
from sklearn.metrics import recall_score
score1 = accuracy_score(y_test,y_pred)
score2 = precision_score(y_test,y_pred)
score3= recall_score(y_test,y_pred)
print("\n")
print("Accuracy is ",round(score1*100,2),"%")
print("Precision is ",round(score2,2))
print("Recall is ",round(score3,2))


# from sklearn.model_selection import GridSearchCV 
# from sklearn.linear_model import LogisticRegression

# param_grid = { 'C': [0.1, 1, 10], 'penalty': ['l1', 'l2'], 'solver': ['liblinear'] }

# grid_search = GridSearchCV(LogisticRegression(random_state=0), param_grid, cv=5, scoring='accuracy')
# grid_search.fit(X_train, y_train)

# best_params = grid_search.best_params_ 
# print(f"Best Parameters: {best_params}") 
# best_model = grid_search.best_estimator_

# from sklearn.metrics import accuracy_score, precision_score, recall_score,f1_score

# score1 = accuracy_score(y_test, y_pred) 
# score2 = precision_score(y_test, y_pred) 
# score3 = recall_score(y_test, y_pred) 
# score4 = f1_score(y_test, y_pred)

# print("\n") 
# print("Accuracy is ", round(score1 * 100, 2), "%") 
# print("Precision is ", round(score2, 2)) 
# print("Recall is ", round(score3, 2)) 
# print("F1 Score is ", round(score4, 2))


# review = "The food was good"
# result = classifier.predict(cv.transform([review]))
# if result == 1:
#   print("Positive")
# else:
#   print("Negative")

# def predict():
#   review = input("Enter the review:")
#   result = classifier.predict(cv.transform([review]))
#   if result == 1:
#     print("Positive")
#   else:
#     print("Negative")



# predict()